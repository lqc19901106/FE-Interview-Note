# JavaScript基础

## 数据类型

### js数据类型

- 基本数据类型：number、boolean、string、null、undefined 
- 引用数据类型： Object、Array、Date、Regexp 

**bigint**

它在某些方面类似于 Number ，但是也有几个关键的不同点：不能用于 Math 对象中的方法；不能和任何 Number 实例混合运算，两者必须转换成同一种类型。在两种类型来回转换时要小心，因为 BigInt 变量在转换成 Number 变量时可能会丢失精度。

### `==`和`===`的区别
> === 做比较的时候不允许做数据类型的转换
```js
console.log(333 === new Number(333));
// result  // false
// typeof 333 // number
// typeof new Number(333)  //object
// 值相等， 数据类型不同
```
> **typeof 对象所有的值**

number string boolean object undefined function 

## 作用域

包括静态作用域和动态作用域，静态作用域也叫词法作用域，javascript采用的是静态作用域

**使用自执行的匿名函数包裹块语句构建块作用域，也叫私有作用域**

```js
(function(){
  for(var i = 0;i < 10; i++){
    console.log(i);  // 0-9
  }
  console.log(i); //10
})();
console.log(i); //Uncaught ReferenceError: i is not defined

```

Javascript中有三种作用域：

1. 全局作用域；
2. 函数作用域；
3. 块级作用域；

## 作用域链

当在Javascript中使用一个变量的时候，首先Javascript引擎会尝试在当前作用域下去寻找该变量，如果没找到，再到它的上层作用域寻找，以此类推直到找到该变量或是已经到了全局作用域。

如果在全局作用域里仍然找不到该变量，它就会在全局范围内隐式声明该变量(非严格模式下)或是直接报错。

### this

> 

## 执行上下文

 javascript运行的代码环境有三种：

​        全局代码：代码默认运行的环境，最先会进入到全局环境中

​        函数代码：在函数的局部环境中运行的代码

​        Eval代码：在Eval()函数中运行的代码

**每当一个函数被调用时就会为该函数创建一个执行上下文，每个函数都有自己的执行上下文**

> js代码的执行过程
>
> 1. 全局上下文压入栈顶
> 2. 执行某一函数就为其创建一个执行上下文，并压入栈顶
> 3. 栈顶的函数执行完之后它的执行上下文就会从js调用栈中弹出，并且变量对象(VO)随之销毁
> 4. 所有函数执行完之后js调用栈（ECS）中只剩下全局上下文，在应用关闭时销

 VO(变量对象)： 创建执行上下文时与之关联的会有一个变量对象，该上下文中的所有变量和函数全都保存在这个对象中。

 AO(活动对象)：  进入到一个执行上下文时，此执行上下文中的变量和函数都可以被访问到，可以理解为被激活。

**执行上下文的创建和执行过程**

1. 找到当前上下文调用函数的代码

2. 执行代码之前，先创建执行上下文

3. 创建阶段：
   1. 创建变量对象(VO)： 
      1. **创建arguments，检查当前上下文的参数，建立该对象下的属性和属性值**
      2. 扫描上下文的函数申明：
         - 每扫描到一个函数什么就会在VO里面用函数名创建一个属性，为一个指针，指向该函数在内存中的地址
         - 如果函数名在VO中已经存在，对应的属性值会被新的引用覆盖
      3. 扫描上下文的变量申明：
         - 每扫描到一个变量就会用变量名作为属性名，其值初始化为undefined
         - 如果该变量名在VO中已经存在，则直接跳过继续扫描
   2. 初始化作用域链
   3. 确定上下文中this的指向
4. 代码执行阶段：**变量赋值，函数引用，执行代码**

> ****函数声明先于变量声明****

## 原型链

构造函数创建后，构造函数会有一个显式的原型对象prototype

每一个对象实例，都会有一个隐式的原型对象 _ _ proto _ _

隐式的原型对象 _ _ proto _ _总等于该实例构造函数的原型对象

当调用某种方法或查找某种属性时，首先会在自身调用和查找，如果自身并没有该属性或方法，则会去它的 _ _ proto _ _属性中调用查找，也就是它构造函数的prototype中调用查找。

![](/Users/liuqichao/Workspace/front-interview/img/原型链图.png)

## 事件循环（Event Loop）
> 1、所有代码都要经过JS调用栈执行
> 2、遇到异步事件，交给浏览器的其他模块管理
> 3、任务队列之中走的是回调函数
> 4、调用栈中的任务执行完，再放事件队列中的任务进入

① 任务队列，也就是事件队列，分为 宏任务(macro-task) 和 微任务(micro-task)
② macro-task 包括：setTimeout、setInterval、setImmediate(node)、requestAnimationFrame、I/O流、UI 渲染(嗯，UI渲染也是异步的)
③ micro-task 包括：process.nextTick(node)、Promises、Object.observer、MutationObserver

我们先口述一下现在的事件执行顺序：
① 先顺序从上向下执行当前全局上下文
② 遇到异步事件就将其交给对应的浏览器模块
③ 浏览器的模块处理完之后，宏任务放入宏任务队列，微任务放入微任务队列
④ 当函数调用栈清空，开始执行任务队列，先执行微任务队列，执行完微任务队列再执行宏任务队列
⑤ 当执行任务队列时，可以认为重新开了一个空的宏任务队列和一个空的微任务队列，将新产生的异步任务最终放入新的任务队列，当前任务队列执行完成后，当前宏队列和微队列就清除，然后再去执行新的微任务队列，执行新的宏任务队列，新开微队列，新开宏队列。。。。一直循环下去，直到任务队列全部为空。

## 垃圾回收机制

> 什么是垃圾：没有被引用的对象就叫垃圾

> 原理：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。
> JavaScript垃圾回收的机制很简单：找出不再使用的变量，然后释放掉其占用的内存，但是这个过程不是实时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。

**js 常用的垃圾回收机制由标记清除和引用技术**
### 标记清除

> 工作原理：是当变量进入环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。

工作流程：

1. 垃圾回收器，在运行的时候会给存储在内存中的所有变量都加上标记。
2. 去掉环境中的变量以及被环境中的变量引用的变量的标记。
3. 再被加上标记的会被视为准备删除的变量。
4. 垃圾回收器完成内存清除工作，销毁那些带标记的值并回收他们所占用的内存空间。

### 引用计数

> 工作原理：跟踪记录每个值被引用的次数。

工作流程：

1. 声明了一个变量并将一个引用类型的值赋值给这个变量，这个引用类型值的引用次数就是1。
2. 同一个值又被赋值给另一个变量，这个引用类型值的引用次数加1.
3. 当包含这个引用类型值的变量又被赋值成另一个值了，那么这个引用类型值的引用次数减1.
4. 当引用次数变成0时，说明没办法访问这个值了。
5. 当垃圾收集器下一次运行时，它就会释放引用次数是0的值所占的内存。

但是循环引用的时候就会释放不掉内存。循环引用就是对象A中包含另一个指向对象B的指针，B中也包含一个指向A的引用。
因为IE中的BOM、DOM的实现使用了COM，而COM对象使用的垃圾收集机制是引用计数策略。所以会存在循环引用的问题。

解决：手工断开js对象和DOM之间的链接。赋值为null。IE9把DOM和BOM转换成真正的JS对象了，所以避免了这个问题。

### 引发内存泄漏的情况
1. 意外的全局变量引起的内存泄漏。

原因：全局变量，不会被回收。
解决：使用严格模式避免。

2. 闭包引起的内存泄漏

原因：闭包可以维持函数内局部变量，使其得不到释放。
解决：将事件处理函数定义在外部，解除闭包,或者在定义事件处理函数的外部函数中，删除对dom的引用。

3. 没有清理的DOM元素引用

原因：虽然别的地方删除了，但是对象中还存在对dom的引用
解决：手动删除。

4. 被遗忘的定时器或者回调

原因：定时器中有dom的引用，即使dom删除了，但是定时器还在，所以内存中还是有这个dom。
解决：手动删除定时器和dom。

5. 子元素存在引用引起的内存泄漏

原因：div中的ul li  得到这个div，会间接引用某个得到的li，那么此时因为div间接引用li，即使li被清空，也还是在内存中，并且只要li不被删除，他的父元素都不会被删除。
解决：手动删除清空。

### 什么放在内存中？什么不放在内存中？

基本类型是：undefined、null、boolean、number、string

基本类型的值存在内存中，被保存在栈内存中。从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本。

引用类型：object

引用类型的值是对象，保存在堆内存中。

1. 包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针。从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象。
2. js不允许直接访问内存中的位置，也就是不能直接访问操作对象的内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。

### 栈和堆的区别
　　一、堆栈空间分配区别：
　　1、栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈；
　　2、堆（操作系统）： 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。
　　二、堆栈缓存方式区别：
　　1、栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放；
　　2、堆是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。
　　三、堆栈数据结构区别：
　　堆（数据结构）：堆可以被看成是一棵树，如：堆排序；
　　栈（数据结构）：一种先进后出的数据结构。

## 创建对象的方式

1. 工厂模式
```
function createPerson(name, age, job){
    var obj = {};
    obj.name = name;
    obj.age = age;
    obj.job = job;
    obj.sayName = function() {
        alert(this.name);
    }
    return obj;
}

var person1 = createPerson('ss', 18, 'developer')
```
2. 构造函数模式
```
function Person(name, age, job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = function() {
        alert(this.name)
    }
}
var person1 = new Person('ss', 18, 'developer');
```
3. 原型模式
4. 组合使用构造函数模式和原型模式
5. 动态原型模式
6. 寄生构造函数模式
7. 稳妥构造函数模式


## 继承

> **构造函数继承**

```js
function Person(name){
	this.name = name;
}
function Child(){
	Person.apply(this, arguments);
}
```

> 通过`apply`、`call`在新创建的类上获取父类的成员和方法

> **原型链继承**

```
function Person(name){
	this.name = name;
}
function Children(name){
	this.name = name;
}
Children.prototype = new Person();
```

> 通过原型链之间的指向关系进行委托关联

## ES6

### 1. let 和 const

- var的声明会挂在到window上，let和const不会。
- var声明存在变量提升；let、const不会。
- let和const声明形成块作用域
- 同一作用域下let和const不能声明同名变量，而var可以
- 暂存死区

```js
var a = 100;
if(1){
    a = 10;
    //在当前块作用域中存在a使用let/const声明的情况下，给a赋值10时，只会在当前作用域找变量a，
    // 而这时，还未到声明时候，所以控制台Error:a is not defined
    let a = 1;
}
```

- const
    - 一旦声明必须赋值,不能使用null占位。
    - 声明后不能再修改
    - 如果声明的是复合类型数据，可以修改其属性

### 2. 箭头函数和普通函数的区别
- 箭头函数是匿名函数，不能作为构造函数，不能使用new
- 箭头函数不绑定arguments，取而代之用rest参数...解决
- 箭头函数不绑定this，会捕获其所在的上下文的this值，作为自己的this值
- 箭头函数通过 call()  或   apply() 方法调用一个函数时，只传入了一个参数，对 this 并没有影响。

```js
let obj2 = {
    a: 10,
    b: function(n) {
        let f = (n) => n + this.a;
        return f(n);
    },
    c: function(n) {
        let f = (n) => n + this.a;
        let m = {
            a: 20
        };
        return f.call(m,n);
    }
};
console.log(obj2.b(1));  // 11
console.log(obj2.c(1));  // 11 调用了call函数也没有将this指向m对象
```
- 箭头函数没有原型属性
- 箭头函数不能当做Generator函数,不能使用yield关键字

> 箭头函数的 this 永远指向其上下文的  this ，任何方法都改变不了其指向，如 call() ,  bind() ,  apply() 

### 3. `generator`

### 4. class

### 5. async/await、Promise

## 相关面试题

### 1. DOM事件流

主要由三个阶段 捕阶段 -> 目标阶段 -> 冒泡阶段，这个传播过程叫做事件流。
1. 捕获阶段： 从根节点window到目标节点，即最近的、最精确的元素节点
2. 目标阶段：根节点上的事件触发按代码执行顺序触发
3. 冒泡阶段： 从目标节点到根节点

阻止冒泡事件 `event.stopPropagation()`;
马上停止传播：`event.stopImmediatePropagation()`;

> 而且event.stopPropagation()在目标阶段不会生效。如果目标阶段有 a、b、c 三个触发事件会按序执行，在 b 事件里设置event.stopPropagation()并不会影响 c 事件的触发。 但是如果在 b 事件里设置event.stopImmediatePropagation()后 ，事件触发到b之后就会停止触发后面的所有事件。

### 作用域链和原型链的区别
作用域链是针对变量的，原型链是针对原型链的。

### try{}里面有return,finally里的代码会不会执行,什么时候被执行?

会执行,在方法返回给调用者前执行,因为如果存在finally代码块,try中的return语句
不会立马返回给调用者,而是记录下返回值待finally代码块执行完毕之后再返回;

1、不管有木有出现异常，finally块中代码都会执行；
2、当try和catch中有return时，finally仍然会执行；
3、finally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，管finally中的代码怎么样，返回的值都不会改变，任然是之前保存的值），所以函数返回值是在finally执行前确定的；
4、finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值。




